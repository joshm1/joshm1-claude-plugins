# Port Isolation Deep Dive

This reference explains the port isolation strategy used for Git worktrees in detail.

## The Problem

When working with multiple Git worktrees simultaneously, each worktree may run its own:
- Development server (Vite, Webpack, Next.js)
- API server (Express, FastAPI, Rails)
- Database (PostgreSQL, MySQL, Redis)
- Other services (worker processes, websocket servers)

Running the same service from multiple worktrees causes **port conflicts**:
```
Error: listen EADDRINUSE: address already in use :::3000
```

## Solution: PORT_OFFSET

Instead of manually assigning unique ports, we use a **deterministic offset** system:

```
actual_port = base_port + PORT_OFFSET
```

### Auto-Detection

The script automatically finds **any** environment variable containing `PORT` or `port`:
- `PORT=3000` → `PORT=3347`
- `VITE_PORT=5173` → `VITE_PORT=5520`
- `MY_CUSTOM_SERVICE_PORT=9000` → `MY_CUSTOM_SERVICE_PORT=9347`

Known services get nice labels (e.g., "Vite", "PostgreSQL"), while unknown ones derive labels from the variable name (e.g., `MY_CUSTOM_SERVICE_PORT` → "My Custom Service").

### Offset Calculation

The offset is calculated from the worktree name using a hash:

```python
import hashlib

def calculate_port_offset(worktree_name: str) -> int:
    """Generate deterministic offset (100-999) from name."""
    hash_digest = hashlib.md5(worktree_name.encode()).hexdigest()
    return 100 + (int(hash_digest[:4], 16) % 900)
```

**Properties:**
- **Deterministic** - Same name always produces same offset
- **Range 100-999** - Avoids low ports, provides ~900 unique values
- **Collision-resistant** - Hash distribution minimizes conflicts

### Example Offsets

| Worktree Name | Offset |
|---------------|--------|
| feature-auth | 347 |
| feature-api | 521 |
| bugfix-login | 183 |
| main-backup | 892 |

### Port Mapping

With offset 347:

| Service | Base Port | Actual Port |
|---------|-----------|-------------|
| Vite | 3000 | 3347 |
| Webpack | 8080 | 8427 |
| Express | 3001 | 3348 |
| PostgreSQL | 5432 | 5779 |
| Redis | 6379 | 6726 |
| MySQL | 3306 | 3653 |

## Framework Integration

### Vite

```javascript
// vite.config.js
export default defineConfig({
  server: {
    port: parseInt(process.env.VITE_PORT || process.env.PORT || '3000')
  }
})
```

### Webpack Dev Server

```javascript
// webpack.config.js
module.exports = {
  devServer: {
    port: parseInt(process.env.PORT || '8080')
  }
}
```

### Next.js

```bash
# Start with custom port
PORT=3347 next dev

# Or in package.json
"scripts": {
  "dev": "next dev -p ${PORT:-3000}"
}
```

### Create React App

```bash
PORT=3347 npm start
```

### Express/Node.js

```javascript
const PORT = parseInt(process.env.PORT || '3000');
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### FastAPI/Uvicorn

```bash
uvicorn main:app --port ${PORT:-8000}
```

### Django

```bash
python manage.py runserver 0.0.0.0:${PORT:-8000}
```

### Rails

```bash
rails server -p ${PORT:-3000}
```

## Docker Compose Integration

Docker Compose can read from `.env` files directly:

```yaml
# docker-compose.yml
version: '3.8'
services:
  web:
    build: .
    ports:
      - "${PORT:-3000}:3000"

  db:
    image: postgres:15
    ports:
      - "${DB_PORT:-5432}:5432"
    environment:
      POSTGRES_DB: myapp

  redis:
    image: redis:7
    ports:
      - "${REDIS_PORT:-6379}:6379"
```

The `.env.local` generated by the setup script:
```bash
PORT=3347
DB_PORT=5779
REDIS_PORT=6726
```

## Database Isolation

### PostgreSQL

**Option 1: Different ports (same host)**
```
postgresql://localhost:5779/myapp
```

**Option 2: Different database names (same port)**
```
postgresql://localhost:5432/myapp_feature_auth
```

**Option 3: Both (maximum isolation)**
```
postgresql://localhost:5779/myapp_feature_auth
```

The setup script uses Option 3 for maximum isolation.

### Creating Worktree Databases

```bash
# PostgreSQL
createdb myapp_feature_auth

# MySQL
mysql -e "CREATE DATABASE myapp_feature_auth"

# SQLite (no action needed - file-based)
```

### Connection String Transformation

```
Before: postgresql://user:pass@localhost:5432/myapp
After:  postgresql://user:pass@localhost:5779/myapp_feature_auth
                                        ^^^^      ^^^^^^^^^^^^^^^
                                        |         Database suffix
                                        Port offset applied
```

## Troubleshooting

### Finding Port Conflicts

```bash
# Check what's using a port
lsof -i :3000

# Check all listening ports
lsof -i -P -n | grep LISTEN

# macOS: check specific port
sudo lsof -i tcp:3000
```

### Killing Stuck Processes

```bash
# Find and kill by port
lsof -ti :3000 | xargs kill -9

# Or use fuser (Linux)
fuser -k 3000/tcp
```

### Verifying Port Availability

```bash
# Check if port is free
nc -z localhost 3347 || echo "Port 3347 is available"

# Or using Python
python -c "import socket; s=socket.socket(); s.bind(('',3347)); s.close(); print('Available')"
```

### Common Issues

**Issue: Port still in use after stopping server**

Some frameworks hold ports briefly. Wait a few seconds or:
```bash
# Force immediate reuse
sysctl -w net.ipv4.tcp_tw_reuse=1  # Linux
```

**Issue: Different offset calculated each time**

Ensure worktree name is consistent. The offset is based on the directory name:
```bash
# These produce DIFFERENT offsets:
git worktree add ../feature-auth feature-auth
git worktree add ../FEATURE-AUTH feature-auth  # Different!
```

**Issue: Services not respecting environment variables**

Some services cache environment on startup. Restart the service after changing `.env.local`.

## Advanced: Port Registry

For complex setups with many worktrees, consider a central registry:

```json
// ~/.worktree-ports.json
{
  "/path/to/project": {
    "main": {
      "offset": 0,
      "ports": {"web": 3000, "api": 8000, "db": 5432}
    },
    "feature-auth": {
      "offset": 347,
      "ports": {"web": 3347, "api": 8347, "db": 5779}
    }
  }
}
```

This enables:
- Central port allocation tracking
- Conflict detection across projects
- Easy port lookup

## Best Practices

1. **Use environment variables** - Never hardcode ports in source
2. **Document base ports** - Keep a list of services and their base ports
3. **Use offset range wisely** - 100-999 handles most cases
4. **Clean up** - Remove worktrees when done to free port assignments
5. **Monitor ports** - Periodically check for stuck processes
6. **Consider Docker** - Container isolation avoids port conflicts entirely
